---
agent: agent
description: "코드 품질 개선 및 아키텍처 계층 분리를 위한 리팩토링 수행"
---

릴리즈 전 또는 Sprint 종료 전 코드 품질을 개선하고, 아키텍처 원칙에 맞춰 구조를 최적화한다.

## 트리거

- 사용자가 리팩토링을 요청할 때
- Sprint 종료 전 코드 정리가 필요할 때
- 릴리즈 준비 단계
- 비즈니스 로직과 UI가 혼재되어 유지보수가 어려울 때

## 리팩토링 금지 상황

다음 상황에서는 리팩토링을 보류한다:

- 테스트 커버리지가 현저히 낮은 영역 (먼저 테스트 추가)
- 릴리즈 직전 핫픽스 상황
- 요구사항이 아직 확정되지 않은 기능

## 리팩토링 체크리스트

### 1. 미사용 코드 제거

| 대상             | 기준                            | 자동화        |
| ---------------- | ------------------------------- | ------------- |
| 미사용 import    | IDE/lint 경고 대상              | ✅ lint --fix |
| 미사용 변수/함수 | 호출되지 않는 코드              | ✅ lint       |
| 주석 처리된 코드 | 전체 삭제 (Git 히스토리에 존재) | ❌ 수동       |
| TODO/FIXME 주석  | GitHub Issue로 이전 후 삭제     | ❌ 수동       |
| 미래용 코드      | "나중에 사용" 목적의 코드 삭제  | ❌ 수동       |

### 2. 중복 코드 제거

| 대상                  | 조치                         | 우선순위 |
| --------------------- | ---------------------------- | -------- |
| 동일 로직 반복 (3회+) | 공통 함수/Extension으로 추출 | P0       |
| 유사 컴포넌트         | Generic 또는 Protocol로 통합 | P1       |
| 상수 중복             | Constants 파일로 통합        | P1       |
| 타입 중복             | Models 파일로 통합           | P1       |

### 3. 파일 크기 최적화

| 기준       | 조치           |
| ---------- | -------------- |
| 200줄 이상 | 분리 검토 대상 |
| 400줄 이상 | 반드시 분리    |

분리 기준:

- **View**: 순수 UI 렌더링만 담당
- **ViewModel**: 상태 관리 및 비즈니스 로직
- **Model**: 데이터 구조 정의
- **Service**: 외부 API/시스템 통신

### 4. 아키텍처 계층 점검

STRUCTURE 문서와 비교하여:

| 점검 항목             | 위반 예시               | 조치                     |
| --------------------- | ----------------------- | ------------------------ |
| View → Data 직접 호출 | View 내 URLSession 호출 | ViewModel/Service로 분리 |
| 계층 역전             | Model이 View 참조       | 의존성 방향 수정         |
| 위치 부적합           | /Utils에 있는 API 코드  | /Services로 이동         |
| 순환 참조             | A → B → A               | 의존성 구조 재설계       |

### 5. 코드 품질

| 항목             | 체크                    | 우선순위 |
| ---------------- | ----------------------- | -------- |
| Any 타입         | 구체적 타입으로 교체    | P0       |
| Force unwrap (!) | guard/if let으로 교체   | P0       |
| print() 문       | 삭제 또는 Logger로 교체 | P1       |
| 하드코딩 값      | 상수/환경변수로 분리    | P1       |
| 에러 처리        | do-catch 누락 확인      | P0       |
| 매직 넘버        | 의미 있는 상수로 교체   | P2       |

### 6. 성능 점검

| 항목                       | 체크                             |
| -------------------------- | -------------------------------- |
| 불필요한 @State/@Published | 실제 UI 갱신에 필요한지 확인     |
| 과도한 body 재계산         | 뷰 분리 또는 @ViewBuilder 활용   |
| 무거운 연산                | async/background로 이동          |
| 메모리 누수                | weak self 확인, Instruments 점검 |

## 실행 순서

### Phase 1: 사전 준비

1. STRUCTURE 문서 확인
2. 현재 테스트 커버리지 확인
3. lint/컴파일 에러 확인
4. 리팩토링 대상 목록 및 우선순위 작성
5. (대규모 변경 시) 롤백 계획 수립

### Phase 2: 자동화 가능 정리

1. `swiftlint --fix` 실행
2. 미사용 import 제거
3. 포맷팅 정리
4. 빌드 확인

### Phase 3: 수동 코드 정리

1. 미사용 코드/주석 삭제
2. 중복 로직 → 공통 모듈 추출
3. 대용량 파일 분리
4. 테스트 실행

### Phase 4: 아키텍처 정리

1. 계층 위반 코드 식별
2. 비즈니스 로직 → ViewModel/Service로 추출
3. 파일 위치 재배치
4. import 경로 수정
5. 순환 참조 해결
6. 테스트 실행

### Phase 5: 검증 및 문서화

1. 전체 빌드 확인
2. 테스트 전체 실행
3. STRUCTURE 문서 업데이트
4. 변경 사항 기록

## 결과물

리팩토링 완료 후 생성:

```text
/docs/current_sprint/REFACTORING_MMDDNN.md
```

### 결과 보고서 템플릿

```markdown
## 리팩토링 결과

### 요약

- 작업 일시: YYYY-MM-DD
- 대상 범위: (모듈/기능명)
- 총 변경 파일: N개

### 주요 변경 사항

| 분류      | 변경 내용        | 파일                         |
| --------- | ---------------- | ---------------------------- |
| 코드 제거 | 미사용 함수 삭제 | FileA.swift                  |
| 중복 제거 | 공통 함수 추출   | Utils/Common.swift           |
| 계층 분리 | API 호출 분리    | Services/BackupService.swift |

### 삭제된 코드

- 총 N줄 삭제
- 미사용 파일: (목록)

### 추출된 공통 모듈

| 모듈명 | 용도 | 사용처 |
| ------ | ---- | ------ |

### TODO → Issue 이전

| 원본 위치 | Issue 번호 | 내용 |
| --------- | ---------- | ---- |

### 테스트 결과

- 빌드: ✅ 성공
- 단위 테스트: ✅ N개 통과
- UI 테스트: ✅ N개 통과
```

## 주의사항

- 한 번에 너무 많은 변경 금지 (커밋 단위로 분리)
- 리팩토링과 기능 변경을 섞지 않음
- 변경 전후 동작이 동일해야 함 (행위 보존)
- 커밋 메시지: `refactor: <변경 내용 요약>`
